#!/bin/bash
#
# Build script
#
# Support script to automate software builds outside of base distribution
# packages
#
# Copyright 2011-2018 Mark Verboom
#
# This file is part of Build.
# 
#     Build is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Build is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Build.  If not, see <http://www.gnu.org/licenses/>.

require_software() {
   echo gawk grep git svn wget fakeroot bzip2 hg
}

distro_get() {
   if test "$( which dpkg-query)"
   then
      echo debian
      exit 0
   fi
   echo unknown
   exit 1
}

recipe_item_get() {
   local recipe=$RECIPEDIR/$1.recipe
   local label=$2
   local item=$3

   local value=$( recipe_section_get $1 $label optional | grep "^${item}=" )
   if test "$value" = "" -a "$#" = 4
   then
      echo $4
   else
      echo ${value/*=/}
   fi
   test "$value" = "" && return 0 || return 1
}

recipe_section_get() {
   local recipename=$1
   local recipe=$RECIPEDIR/$recipename.recipe
   local label=$2
   local opt=$3

   test ! -f $recipe && { test "$opt" = "" && { >&2 output "Recipe $recipename ($recipe) does not exist."; return 1; } }

   grep "^\[$label\]" $recipe > /dev/null 2>&1  || { test "$opt" = "" &&  { >&2 output "No section $label found in recipe $recipe"; exit 1; } }
   awk "BEGIN {found=0;} /^\[/ {found=0;} {if (found==1) { print \$0;}}; /^\[$label\]/ { found=1;}" $recipe | grep -v "^#"
}

build_require() {
   local pkgs=$*
   local missing=0
   local toinst=""
   local toinsttr=""
   local pkg

   for pkg in $pkgs
   do
      dpkg-query -s ${pkg/*@/} > /dev/null 2>&1
      if test $? -ne 0
      then
         output "Package $pkg required for build, but not installed."
         if test "$INSTDEP" = "yes" 
         then
            test "$pkg" = "${pkg/*@/}" && toinst="$toinst $pkg" || toinsttr="$toinsttr $pkg"
         else
            missing=1
         fi
      fi
   done
   test "$toinst" != "" && { sudo apt-get -qq -y install $toinst > /dev/null 2>&1 || { output "Error installing dependancies ($toinst)."; return 1 ;} }
   test "$toinsttr" != "" && for pkg in $toinsttr
   do
      sudo apt-get -qq -y -t ${pkg/@*/} install ${pkg/*@/}  > /dev/null 2>&1 || { output "Error installing dependancy ($pkg)."; return 1 ; }
   done
   test $missing -eq 1 && return 1
   return 0
}

build_require_remove() {
   local pkgs="$1"
   local pkg
   local list
   for pkg in $pkgs
   do
      list="$list ${pkg/*@/}"
   done
   sudo apt-get -qq -y --purge remove $list > /dev/null
}

build() {
   B_NAME=$1
   B_VERSION=$2
   if test "$B_INSTANCE" != ""
   then
      versiondir=$B_VERSION-$B_INSTANCE
   else
      versiondir=$B_VERSION
   fi
   local pkgs=$( recipe_section_get $B_NAME REQUIRED opt )
   ( test $? -eq 0 &&  build_require $pkgs ) || return 1

   test "$B_INSTANCE" != "" && ID=${B_NAME}_${B_VERSION}-${B_INSTANCE}_${B_ARCH} || ID=${B_NAME}_${B_VERSION}_${B_ARCH}
   B_BUILDNR=$( package_buildnr_get $ID )
   local CMD=$( recipe_section_get $B_NAME BUILD ) || return 1
   test $? -ne 0 && { ERR=1 output $CMD ; return 1; }
   local TMP=$( mktemp -p $TMPDIR -d )
   B_INSTALLDIR=$DESTDIR/$B_ARCH/$B_NAME-$versiondir
   test $FORCE -eq 1 && rm -rf $B_INSTALLDIR
   mkdir -p $B_INSTALLDIR

   # Define build environment variables and functions
   B_CACHEDIR=$CACHEDIR
   test -d $RECIPEDIR/$B_NAME.files/B_BUILD && B_FILES=$RECIPEDIR/$B_NAME.files/B_BUILD
   B_PKGLIST=$PKGLIST
   export B_VERSION B_INSTALLDIR B_ARCH B_INSTANCE B_CACHEDIR B_NAME B_BUILDNR B_FILES
   B_GET() {
      test ! $# -ge 3 && { >&2 echo "Insufficient arguments to B_GET."; exit 1; }
      local method=$1
      local url=$2
      local fn=$3
      local opts=$4
      local targetdir=$B_CACHEDIR/$B_NAME
      local target=$targetdir/$fn-$B_VERSION
      local targetnover=$targetdir/$fn
      case $method in
      "http")
         if ! test -f $target
         then
            test -d $targetdir || mkdir -p $targetdir
            echo "Http downloading files.."
            wget -q -O $target $url || rm $target
            test $? -ne 0 && { echo "Error downloading file."; exit 1; }
         fi
         cp $target $fn
      ;;
      "git")
         if ! test -f $targetnover
         then
            test -d $targetdir || mkdir -p $targetdir
            echo "Git downloading files.."
            git clone $opts $url $fn
            test $? -ne 0 && { echo "Error cloning repository."; exit 1; }
            tar cfz $targetnover $fn
         else
            tar xzf $targetnover
            cd $fn
            git remote update
            if test "$(git rev-parse @)" != "$(git rev-parse @{u})"
            then
               git pull
               cd ..
               tar cfz $targetnover $fn
            else
               cd ..
            fi
         fi
      ;;
      "hg")
         if ! test -f $targetnover
         then
            test -d $targetdir || mkdir -p $targetdir
            echo "Mercurial downloading files.."
            hg clone $url $fn
            test $? -ne 0 && { echo "Error cloning repository."; exit 1; }
            tar cfz $targetnover $fn
         else
            tar xzf $targetnover
            cd $fn
            if test "$(hg id | cut -d' ' -f 1)" != "$(hg id $url)"
            then
               hg pull
               cd ..
               tar cfz $targetnover $fn
            else
               cd ..
            fi
         fi
      ;;
      "svn")  
         if ! test -f $targetnover
         then
            test -d $targetdir || mkdir -p $targetdir
            echo "Subversion downloading files.."
            svn checkout --non-interactive --trust-server-cert -q $url $fn
            test $? -ne 0 && { echo "Error checking out repository."; exit 1; }
            tar cfz $targetnover $fn
         else
            tar xzf $targetnover
            cd $fn
            if test "$(svn info --non-interactive --trust-server-cert $url | grep Revision | cut -d' ' -f2)" != "$( svn info --non-interactive --trust-server-cert | grep Revision | cut -d' ' -f 2)"
            then
               svn update --non-interactive --trust-server-cert
               cd ..
               tar cfz $targetnover $fn
            else
               cd ..
            fi
         fi
      ;;
      *)
         echo "B_GET: unknown method $method"
         return 1
      ;;
      esac
   }
   export -f B_GET
   B_UPDATEPKGBLD() {
      test -f ~/.buildrc && . ~/.buildrc
      if test "$B_INSTANCE" != ""
      then
         local ID=${B_NAME}_${B_VERSION}-${B_INSTANCE}_${B_ARCH}
      else
         local ID=${B_NAME}_${B_VERSION}_${B_ARCH}
      fi
      grep "^$ID" $PKGLIST > /dev/null && sed -i "/^$ID/d" $PKGLIST
      echo -e "$ID\t$B_BUILDNR" >> $PKGLIST
   }
   export -f B_UPDATEPKGBLD
   B_LINKFILES() {
      local src=$1; local dst=$2
      test -d $B_INSTALLDIR/$src || { echo "B_LINKFILES: source needs to be a directory within the B_INSTALLDIR tree."; exit 1; }
      test -d $B_INSTALLDIR/$dst || mkdir -p $B_INSTALLDIR/$dst
      local name
      for name in $( ls $B_INSTALLDIR/$src | grep -v ".real$" )
      do
         ln -s $src/$name $B_INSTALLDIR/$dst
      done
   }
   export -f B_LINKFILES
   cd $TMP
   if test "$QUIET" = "1"; then
      bash $DEBUG -e -c "$CMD" > /dev/null 2>&1
   else
      bash $DEBUG -e -c "$CMD"
   fi
   local result=$?
   cd - > /dev/null
   rm -rf $TMP
   test "$pkgs" != "" -a "$DEINSTDEP" = "yes" -a $B_NOPKGRM -eq 0 && build_require_remove "$pkgs"
   test "$POSTBUILD" != "" -a $B_NOPKGRM -eq 0 && $POSTBUILD
   if test $result -ne 0
   then
      rm -rf $B_INSTALLDIR
      return 1
   fi
   return 0
}

usage() {
   echo "Usage: build [OPTION]... [RECIPE]..."
   echo
   echo "Operation mode:"
   echo "   -c  Check version, runs the version check section of the specified recipe(s)."
   echo "   -b  Build, runs the build version of the specified recipe(s)."
   echo "   -p  Package, runs the package secition of the specified recipe(s)."
   echo "   -r  To repository, creates packages and copies to repository for specfified recipe(s)"
   echo
   echo "Operation modifiers:"
   echo "   -a  Select all recipes available."
   echo "   -v  Specify specific version, will prevent from running version section of recipe(s)"
   echo "   -q  Quiet output"
   echo "   -x  Enable debugging output"
   echo "   -f  Force build for recipe, even if complete build is already available."
   echo "   -i  Specify an instance for a recipe"
   echo "   -R  Don't remove required packages after building and skip any post build script."
   echo "   -h  This help message"
   echo
   exit 1
}

arch_get() {
   local arch=$(uname -m)
   case $arch in
   "i686")
     echo i386
     ;;
   "x86_64")
     echo amd64
     ;;
   *)
     echo $arch
     ;;
   esac
}

package_buildnr_get() {
   local ID=$1
   test -f $PKGLIST || touch $PKGLIST
   local BUILDNR=$(grep "^$ID" $PKGLIST | cut -d'	' -f 2 )
   test "$BUILDNR" = "" && BUILDNR=0
   echo $(( $BUILDNR + 1 ))
}

package_torepo() {
   local type
   local options=""
   local pkg
   local pkgs="$*"
   local splittype
   local RET
   declare -A splittype

   for pkg in $pkgs
   do
      type=${pkg/*./}
      splittype[$type]="${splittype[$type]} $pkg"
   done

   cd $PKGDIR
   RET=0
   for type in ${!splittype[@]}
   do
      case "$type" in
      "deb")
         $TODEBREPO ${splittype[$type]}
         test $? -ne 0 && RET=1
      ;;
      *)
         ERR=1 output "Copy to repository not implemented for type $type"
         RET=1
      ;;
      esac
   done
   return $RET
}

package() {
   local pkg=$1
   local version=$2
   local pkgtype
   local ID

   if test "$B_INSTANCE" != ""
   then
      ID=$pkg-$version-$B_INSTANCE
   else
      ID=$pkg-$version
   fi
   test ! -d "$DESTDIR/$B_ARCH/$ID" && { ERR=1 output "Version $version of $pkg is not available for packaging." ; return 1; }

   if test "$B_INSTANCE" != ""
   then
      ID=${version}-${B_INSTANCE}
   else
      ID=${version}
   fi
   local type=$( recipe_item_get $pkg PKG type )
   for pkgtype in ${type/,/ }
   do
      case $pkgtype in
      "deb")
         package_debian $pkg $version $ID
         return $?
      ;;
      *)
         ERR=1 output "Unknown package type ($pkgtype)."
         return 1
      ;;
      esac
   done
}

package_debian() {
   local pkg=$1
   local version=$2

   local pkgready=$( recipe_item_get $pkg PKG pkgready )
   local P_PKGDIR=${pkg}-${ID}
   if test "$pkgready" = ""
   then
      local P_PKGNAME=${pkg}_${ID}_${B_ARCH}
      local P_BUILDNR=$( package_buildnr_get ${P_PKGNAME} )
      local INFO=$(recipe_section_get $pkg DEB) || return 1
      local TMP=$( mktemp -p $TMPDIR -d )
      mkdir -p $TMP/DEBIAN
      local pkgversion=${version//\-/}-$P_BUILDNR
      test "$PKGPOSTFIX" != "" && INFO=$( echo "$INFO" | sed "/^Package:/ s/$/-$PKGPOSTFIX/" )
      cd $DESTDIR/$B_ARCH/$pkg-$version
      tar pcfB - . | (cd $TMP ; tar pxfB - )
      cd $TMP
      if test -d $RECIPEDIR/$pkg.files/B_DEBIAN
      then
         ( cd $RECIPEDIR/$pkg.files/B_DEBIAN ; tar cf - . ) | tar xf -
      fi

      # Mark config files
      find . -path "*/etc/*" -type f | sed "s/^\.//" > DEBIAN/conffiles
      local configfiles=$( recipe_item_get $pkg PKG configfiles )
      test "$configfiles" != "" && { echo $configfiles | tr ' ' '\n' >> DEBIAN/conffiles; }
      echo "$INFO" | sed "s/B_VERSION/$pkgversion/" | sed "s/B_ARCH/$B_ARCH/" > $TMP/DEBIAN/control
      cd $TMPDIR
      fakeroot dpkg --build $TMP . > $TMP.buildoutput
      result=$?
      local pkgfile=$( cat $TMP.buildoutput | cut -d \' -f 4 )
      pkgfile=${pkgfile/*\//}
      rm -rf $TMP $TMP.buildoutput
      if test $result -ne 0
      then
         ERR=1 output "Error while building package."
         return 1
      fi
      grep "^${P_PKGNAME}_${B_ARCH}" $PKGLIST > /dev/null && sed -i "/^${P_PKGNAME}_${B_ARCH}/d" $PKGLIST
      echo -e "${P_PKGNAME}_${B_ARCH}\t$P_BUILDNR" >> $PKGLIST
      mv $TMPDIR/$pkgfile $PKGDIR
   else
      if test "$( echo $DESTDIR/$B_ARCH/${P_PKGDIR}/*.deb )" = "$DESTDIR/$B_ARCH/${P_PKGDIR}/*.deb"
      then
         ERR=1 output "Recipe indicates package should be in build dir, but it isn't."
         return 1
      else
         file="$DESTDIR/$B_ARCH/${P_PKGDIR}/*.deb"
         cp $file $PKGDIR
         pkgfile=$(basename $DESTDIR/$B_ARCH/${P_PKGDIR}/*.deb)
      fi
   fi
   echo $pkgfile
}

version_get() {
   local pkg=$1
   local CMD

   export B_SARCH
   export B_NAME=$1
   B_GITVER() {
      exp=""
      test "$2" != "" && exp="-e $2"
      git ls-remote --tags $1 | grep -v '{}' | cut -d '/' -f 3  | sed "s/^v//" | grep -v -e "preview\|rc\|a\|b" $exp | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n | tail -1
   }
   B_GITHUBVER() {
      wget -q -O - $1 | sed '/datetime=/!d; s/.*time-ago datetime="[TZ\:0-9\-]*">\([^<]*\)<.*/\1/' | while read line; do date --date="$line" "+%Y%m%d"; done | sort | tail -1
   }
   B_SVNDATE() {
      date -d "$(svn info --non-interactive --trust-server-cert $1 | grep 'Last Changed Date:' | cut -d':' -f2-)" "+%Y%m%d"
   }
   B_SVNREV() {
      svn info --non-interactive --trust-server-cert $1 | grep Revision | cut -d' ' -f2
   }
   B_HGREV() {
      hg id $1
   }
   export -f B_GITVER B_GITHUBVER B_SVNDATE B_SVNREV B_HGREV
   CMD=$( recipe_section_get $pkg VERSION )
   test $? -ne 0 && { output $CMD ; return 1; }
   local ver=$( bash $DEBUG -e -c "$CMD" 2>/dev/null )
   test $? -ne 0 && { >&2 output "Error while running version command for $pkg." ; return 1 ; }
   test "$ver" = "" && { >&2 output "Version command for $pkg returned no output." ; return 1 ; }
   echo $ver
   return 0
}

recipe_select_arch() {
   local recipe=$1
   local arch=$( recipe_item_get $recipe INFO arch )
   test "$arch" = "" && arch="$B_SARCH"
   for B_ARCH in ${arch/,/ }
   do
      if test "$B_ARCH" = "all" -o "$B_ARCH" = "$B_SARCH"
      then
         return 0
      fi
   done
   return 1
}

parse_options() {
   FORCE=0 ; DEBUG= ; PKGS= ; FORCEVERSION=
   DO_CHECK=0; DO_BUILD=0; DO_PACKAGE=0; DO_REPO=0; B_NOPKGRM=0
   local all=0

   while getopts :cbprai:Rxqfhv: opt
   do
      case $opt in
      c)
         DO_CHECK=1
      ;;
      b)
         DO_CHECK=2
         DO_BUILD=1
      ;;
      p)
         DO_CHECK=2
         DO_PACKAGE=1
      ;;
      r)
         DO_CHECK=2
         DO_PACKAGE=2
         DO_REPO=1
      ;;
      a)
         all=1
      ;;
      i)
         B_INSTANCE="$OPTARG"
      ;;
      R)
         B_NOPKGRM=1
      ;;
      x)
         set -x
         DEBUG=-x
      ;;
      q)
         QUIET=$(( $QUIET +1 ))
      ;;
      f)
         FORCE=1
      ;;
      h)
         usage
      ;;
      v)
         FORCEVERSION="$OPTARG"
      ;;
      \?)
         echo "Unknown option: -$OPTARG"
         usage
      ;;
      :)
         echo "Option -$OPTARG requires argument"
         usage
      ;;
      esac
   done
   shift $((OPTIND -1))

   for recipe in $*
   do
      recipe_select_arch $recipe && { work_recipes+=($recipe); work_arch[$recipe]=$B_ARCH;} || output "$recipe not for this architecture."
   done

   if test $all -eq 1
   then
      local recipe
      for recipe in $RECIPEDIR/*.recipe
      do
         recipe=$( basename -s .recipe $recipe )
         exclude=$( recipe_item_get $recipe INFO excludefromall )
         recipe_select_arch $recipe && test "$exclude" != "1" && { work_recipes+=( $recipe ) ; work_arch[$recipe]=$B_ARCH; } || output "$recipe not for this architecture."
      done
   fi

   if test ${#work_recipes[@]} -eq 0
   then
      output "No recipe(s) specified."
      exit 1
   fi
   if test "$DO_CHECK" = "0" -a "$DO_BUILD" = "0" -a "$DO_PACKAGE" = "0" -a "$DO_REPO" = "0"
   then
      output "No action specified."
      exit 1
   fi
}

sanity_check() {
   local missing=""
   local name
   for name in $( require_software)
   do
      if ! which $name > /dev/null 2>&1
      then
         missing="$missing $name"
      fi
   done
   test "$missing" != "" && { output "Missing required software to run script:$missing" ; exit 1;}
   test "$PKGDIR" = ""  && { ERR=1 output "PKGDIR not defined"; exit 1;}
   test -d $PKGDIR || { ERR=1 output "PKGDIR $PKGDIR does not exist, creating."; mkdir -p $PKGDIR; }
}

output() {
   local force=0
   test "$1" = "-f" && { force=1; shift; }
   test $QUIET -eq 2 && return
   test $force -eq 0 -a $QUIET -eq 1 && return
   test "$ERR" != "" && (>&2 echo "$1") || echo "$1"
}

check_version_built() {
   local pkg=$1
   local RET=0
   local version

   if test "$FORCEVERSION" != ""; then
      version=$FORCEVERSION
   else
      version=$( version_get $pkg ) || return 2
   fi
   test -d "$DESTDIR/$B_ARCH/$pkg-$version" && { echo "$version" ; RET=1 ;} || echo "$version"
   return $RET
}

lock_get() {
   if test -f $LOCK && pgrep -F $LOCK > /dev/null
   then
      return 1
   else
      echo $$ > $LOCK
      return 0
   fi
}

lock_free() {
   rm -f $LOCK
}

main() {
   local i
   local retval=0
   declare -A packages_torepo
   declare -A work_arch
   LOCK=/tmp/build.lck
   QUIET=0

   DESTDIR=~/build CACHEDIR=~/cache TMPDIR=~/temp
   REDIPEDIR=~/recipes PKGLIST=$RECIPEDIR/pkglist PKGDIR=~/packages
   INSTDEP=yes DEINSTDEP=yes
   test -f ~/.buildrc && . ~/.buildrc || { echo "No configuration file found."; exit 1;}

   sanity_check

   B_SARCH=$( arch_get )
   parse_options "$@"

   if test $DO_CHECK -ne 0; then
      # Get current version and check if already built
      check_found=0
      for i in ${!work_recipes[@]}
      do
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         work_version[$i]=$( check_version_built ${work_recipes[$i]} )
         work_built[$i]=$?
         test $DO_CHECK -eq 1 -o $DO_BUILD -eq 1 -a $FORCE -eq 0 && { test ${work_built[$i]} -eq 1 && output "${work_recipes[$i]} ${work_version[$i]} (already built)"; }
         test $DO_CHECK -eq 1 -o $DO_PACKAGE -ne 0 && { test ${work_built[$1]} -eq 0 && output "${work_recipes[$i]} ${work_version[$i]} (not built)"; }
      done
   fi

   if test $DO_BUILD -ne 0; then
      # If not built or forced, then build
      lock_get || { echo "Unable to get lock, other instance running?"; exit 1; }
      for i in ${!work_recipes[@]}
      do
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         if test ${work_built[$i]} -eq 0 -o $FORCE -eq 1
         then
            build ${work_recipes[$i]} ${work_version[$i]}
            test $? -eq 1 && { output -f "${work_recipes[$i]} ${work_version[$i]} (build failed)"; work_build[$i]=0; retval=1; } || { work_build[$i]=1; output -f "${work_recipes[$i]} ${work_version[$i]} (build succeeded)"; }
         fi
      done
      lock_free
   fi

   if test $DO_PACKAGE -ne 0; then
      # if no build action and version built, package. if build action successful, build.
      for i in ${!work_recipes[@]}
      do
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         b=0
         test $DO_BUILD -eq 0 -a ${work_built[$i]} = 1 && b=1
         test "${work_build[$i]}" = "1" && b=1
         if test $b -eq 1 
         then
            work_package[$i]=$(package ${work_recipes[$i]} ${work_version[$i]})
            test $? -eq 0 && { output "${work_recipes[$i]} ${work_version[$i]} (package created)"; } || { output -f "${work_recipes[$i]} ${work_version[$i]} (package create failed)"; retval=1; }
         fi
      done
   fi

   if test $DO_REPO -ne 0; then
      lock_get || { echo "Unable to get lock, other instance running?"; exit 1; }
      B_ARCH=${work_arch[${work_recipes[$i]}]}
      # if package is succesfully generated
      if test ${#work_package[@]} -gt 0; then
         package_torepo ${work_package[@]}
         test $? -eq 0 && { output "packages pushed to repo"; } || { output -f "packages not pushed to repo"; retval=1; }
      fi
      lock_free
   fi

   return $retval
}

main "$@"
