#!/bin/bash
#
# Build script
#
# Support script to automate software builds outside of base distribution
# packages
#
# Copyright 2011-2019 Mark Verboom
#
# This file is part of Build.
# 
#     Build is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Build is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Build.  If not, see <http://www.gnu.org/licenses/>.
#

usage() {
   echo "Usage: build [OPTION]... [RECIPE]..."
   echo
   echo "Operation mode:"
   echo "   -c  Check version, runs the version check section of the specified recipe(s)."
   echo "   -b  Build, runs the build version of the specified recipe(s)."
   echo "   -p  Package, runs the package secition of the specified recipe(s)."
   echo "   -r  To repository, creates packages and copies to repository for specfified recipe(s)"
   echo
   echo "Operation modifiers:"
   echo "   -a  Select all recipes available."
   echo "   -v  Specify specific version, will prevent from running version section of recipe(s)"
   echo "   -q  Quiet output"
   echo "   -x  Enable debugging output"
   echo "   -s  Drop to a shell when building process fails to inspect."
   echo "   -f  Force build for recipe, even if complete build is already available."
   echo "   -i  Specify an instance for a recipe"
   echo "   -R  Don't remove required packages after building and skip any post build script."
   echo "   -h  This help message"
   echo
   exit 1
}

require_software() {
   case "$OS" in
   "Debian GNU/Linux")
      echo gawk grep git svn wget fakeroot bzip2 hg lsb_release jq xml2
   ;;
   "CentOS Linux")
      echo gawk grep git svn wget bzip2 hg jq
   ;;
   esac
   exit 1
}

recipe_item_get() {
   local recipe; recipe=$RECIPEDIR/$1.recipe
   local label; label=$2
   local item; item=$3

   local value; value=$( recipe_section_get "$1" "$label" optional | grep "^${item}=" )
   if test "$value" = "" -a "$#" = 4
   then
      echo "$4"
   else
      echo "${value/*=/}"
   fi
   test "$value" = "" && return 0 || return 1
}

recipe_section_get() {
   local quiet=0
   test "$1" = "-q" && { quiet=1; shift; }
   local recipename; recipename=$1
   local recipe; recipe=$RECIPEDIR/$recipename.recipe
   local label; label=$2
   local opt; opt=$3

   test ! -f "$recipe" && if test "$opt" = ""; then 
         test "$quiet" = 0 && 
            >&2 output "Recipe $recipename ($recipe) does not exist."
         return 1
      else
         return 0
      fi

   grep "^\[$label\]" "$recipe" > /dev/null 2>&1  || if test "$opt" = ""; then
         test "$quiet" = 0 && 
            >&2 output "No section $label found in recipe $recipe"
         return 1
      else
         return 0
      fi
         
   awk "BEGIN {found=0;} 
        /^\[/ {found=0;} 
        { if (found==1) { 
             print \$0;} };
        /^\[$label\]/ { found=1;}" "$recipe" | grep -v "^#"
}

build_require() {
   local pkgs; pkgs=$*
   local missing; missing=0
   local toinst
   local toinsttr; toinsttr=""
   local pkg

   for pkg in $pkgs
   do
      dpkg-query -s "${pkg/*@/}" 2>&1 | grep not-installed > /dev/null
      if test "${PIPESTATUS[0]}" -ne 0 -o "${PIPESTATUS[1]}" -ne 1
      then
         output "Package $pkg required for build, but not installed."
         if test "$INSTDEP" = "yes"; then
            test "$pkg" = "${pkg/*@/}" && 
               toinst+=("$pkg") || 
               toinsttr+=("$pkg")
         else
            missing=1
         fi
      fi
   done
   test "${#toinst[*]}" != "0" && { 
      sudo apt-get update > /dev/null 2>&1
      sudo apt-get -qq -y install "${toinst[@]}" > /dev/null 2>&1 || 
      { output "Error installing dependancies (${toinst[*]})."; 
       return 1 ;}
   }
   test "${#toinsttr[*]}" != "0" && 
      for pkg in "${toinsttr[@]}"
      do
         sudo apt-get -qq -y -t "${pkg/@*/}" install "${pkg/*@/}"  > /dev/null 2>&1 || 
         { output "Error installing dependancy ($pkg)."; 
           return 1 ; }
      done
   test $missing -eq 1 && return 1
   return 0
}

build_require_remove() {
   local pkgs; pkgs="$1"
   local pkg
   local list
   for pkg in $pkgs
   do
      list+=("${pkg/*@/}")
   done
   sudo apt-get -qq -y --purge remove "${list[@]}" > /dev/null
   # ToDo: Returncode
}

build() {
   B_NAME=$1
   B_VERSION=$2
   if test "$B_INSTANCE" != ""; then
      versiondir=$B_VERSION-$B_INSTANCE
   else
      versiondir=$B_VERSION
   fi

   # Find recipe required section if available
   pkgs=$( recipe_section_get "$B_NAME" "REQUIRED $distr $rel" opt )
   if test "$pkgs" = ""; then
      pkgs=$(recipe_section_get "$B_NAME" "REQUIRED $distr" opt)
      if test "$pkgs" = ""; then
         pkgs=$(recipe_section_get "$B_NAME" "REQUIRED" opt)
      fi
   fi

   test "$PKGPOSTFIX" != "" && pkgs=${pkgs//B_PF/$PKGPOSTFIX}
   build_require "$pkgs" || return 1

   test "$B_INSTANCE" != "" && ID=${B_NAME}_${B_VERSION}-${B_INSTANCE}_${B_ARCH} || ID=${B_NAME}_${B_VERSION}_${B_ARCH}
   B_BUILDNR=$( package_buildnr_get "$ID" )

   # Find BUILD section (add extensions for distribution and distribution version)
   local CMD
   if ! CMD=$( recipe_section_get -q "$B_NAME" "BUILD $distr $rel" ); then
      if ! CMD=$( recipe_section_get -q "$B_NAME" "BUILD $distr" ) ; then
         if ! CMD=$( recipe_section_get -q "$B_NAME" "BUILD" ); then
            return 1
         fi
      fi
   fi
   #test $? -ne 0 && return 1

   local TMP; TMP=$( mktemp -p "$TMPDIR" -d )
   if test "$DESTSPLIT" != ""; then
      B_INSTALLDIR="$DESTDIR/$B_ARCH/$B_NAME/$versiondir"
   else
      B_INSTALLDIR="$DESTDIR/$B_ARCH/$B_NAME-$versiondir"
   fi
   test "$B_FORCE" -eq 1 && rm -rf "$B_INSTALLDIR"
   mkdir -p "$B_INSTALLDIR"

   # Define build environment variables and functions
   B_CACHEDIR=$CACHEDIR
   test -d "$RECIPEDIR/$B_NAME.files/B_BUILD" && B_FILES="$RECIPEDIR/$B_NAME.files/B_BUILD"
   export B_VERSION B_INSTALLDIR B_ARCH B_INSTANCE B_CACHEDIR B_NAME B_BUILDNR B_FILES B_FORCE
   B_GET() {
      test $# -lt 3 && { >&2 echo "Insufficient arguments to B_GET."; exit 1; }
      local method; method=$1
      if test "${2:0:1}" = "-"; then
         local option; option=$2
         shift
      fi
      local url; url=$2
      local fn; fn=$3
      local targetdir; targetdir=$B_CACHEDIR/$B_NAME
      local target; target=$targetdir/$fn-$B_VERSION
      local targetnover; targetnover=$targetdir/$fn
      case $method in
      "http")
         if ! test -f "$target"
         then
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Http downloading files.."
            flock -w 60 "$target" wget -O "$target" "$url" || { rm "$target"; echo "Error downloading file."; exit 1; }
         fi
         flock -w 60 "$target" cp "$target" "$fn"
      ;;
      "sf")
         if ! test -f "$target"
         then
            url=$(wget -q -O - "$url/rss?path=/" | xml2 | grep '/rss/channel/item/link' | grep "$B_VERSION" | cut -d '=' -f 2 | tail -1)
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Http sf downloading files.."
            flock -w 60 "$target" wget -O "$target" "$url" || { rm "$target"; echo "Error downloading file."; exit 1; }
         fi
         flock -w 60 "$target" cp "$target" "$fn"
      ;;
      "git")
         if ! test -f "$targetnover"; then
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Git downloading files.."
            git clone "$url" "$fn"
            test $? -ne 0 && { echo "Error cloning repository."; exit 1; }
            if test "$option" = "-s"; then
               ( cd "$fn" || exit
               git submodule update --init --recursive )
            fi
            flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
         else
            flock -w 60 "$targetnover" tar xzf "$targetnover"
            cd "$fn" || exit
            git remote update
            if test "$(git rev-parse @)" != "$(git rev-parse '@{u}')"
            then
               git pull
               if test "$option" = "-s"; then
                  git submodule update --init --recursive
               fi
               cd ..
               flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
            else
               cd ..
            fi
         fi
      ;;
      "go")
         export GOROOT=/opt/go
         export PATH=${PATH}:${GOROOT}/bin
         export GOPATH
         GOPATH=$(pwd)
         if ! test -f "$targetnover"; then
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Go downloading files.."
            go get -d "$url"
            test $? -ne 0 && { echo "Error downloading repository."; exit 1; }
            flock -w 60 "$targetnover" tar cfz "$targetnover" .
         else
            flock -w 60 "$targetnover" tar xzf "$targetnover"
            go get -d -u "$url"
            test $? -ne 0 && { echo "Error updating repository."; exit 1; }
            flock -w 60 "$targetnover" tar cfz "$targetnover" .
         fi
      ;;
      "hg")
         if ! test -f "$targetnover"; then
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Mercurial downloading files.."
            hg clone "$url" "$fn"
            test $? -ne 0 && { echo "Error cloning repository."; exit 1; }
            flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
         else
            flock -w 60 "$targetnover" tar xzf "$targetnover"
            cd "$fn" || exit
            if test "$(hg id | cut -d' ' -f 1)" != "$(hg id "$url")"; then
               hg pull
               cd ..
               flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
            else
               cd ..
            fi
         fi
      ;;
      "svn")  
         if ! test -f "$targetnover"; then
            test -d "$targetdir" || mkdir -p "$targetdir"
            echo "Subversion downloading files.."
            svn checkout --non-interactive --trust-server-cert -q "$url" "$fn"
            test $? -ne 0 && { echo "Error checking out repository."; exit 1; }
            flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
         else
            flock -w 60 "$targetnover" tar xzf "$targetnover"
            cd "$fn" || exit
            if test "$(svn info --non-interactive --trust-server-cert "$url" | grep Revision | cut -d' ' -f2)" != "$( svn info --non-interactive --trust-server-cert | grep Revision | cut -d' ' -f 2)"; then
               svn update --non-interactive --trust-server-cert
               cd ..
               flock -w 60 "$targetnover" tar cfz "$targetnover" "$fn"
            else
               cd ..
            fi
         fi
      ;;
      *)
         echo "B_GET: unknown method $method"
         return 1
      ;;
      esac
   }
   export -f B_GET
   B_UPDATEPKGBLD() {
      local ID
      # shellcheck source=/home/builduser/.buildrc
      test -f "$HOME/.buildrc" && source "$HOME/.buildrc"
      if test "$B_INSTANCE" != ""; then
         ID=${B_NAME}_${B_VERSION}-${B_INSTANCE}_${B_ARCH}
      else
         ID=${B_NAME}_${B_VERSION}_${B_ARCH}
      fi
      grep "^$ID" "$PKGLIST" > /dev/null && sed -i "/^$ID/d" "$PKGLIST"
      echo -e "$ID\t$B_BUILDNR" >> "$PKGLIST"
   }
   export -f B_UPDATEPKGBLD
   B_LINKFILES() {
      local rec; rec=0
      test "$1" = "-r" && { rec=1; shift; }
      local src; src="$1"; local dst; dst="$2"; local name

      test -d "$B_INSTALLDIR/$src" || { echo "B_LINKFILES: source needs to be a directory within the B_INSTALLDIR tree."; exit 1; }
      test -d "$B_INSTALLDIR/$dst" || mkdir -p "$B_INSTALLDIR/$dst"
      shopt -s nullglob
      pushd "$B_INSTALLDIR/$src" || exit
      for name in *; do
         if test "${name/%.real/}" = "$name"; then
            if test -d "$B_INSTALLDIR/$src/$name" -a "$rec" = 1; then
               B_LINKFILES -r "$src/$name" "$dst/$name"
            else
               ln -s "$src/$name" "$B_INSTALLDIR/$dst"
            fi
         fi
      done
      popd || exit
   }
   export -f B_LINKFILES
   B_LINKFILE() {
      local src; src=$1; local dst; dst=$2
      test -f "$B_INSTALLDIR/$src" || { echo "B_LINKFILE: source needs to be a file within the B_INSTALLDIR tree."; exit 1; }
      test -d "$B_INSTALLDIR/$dst" || mkdir -p "$B_INSTALLDIR/$dst"
      local name
      ln -s "$src" "$B_INSTALLDIR/$dst"
   }
   export -f B_LINKFILE

   # setting to set temporary files to the build folder
   export XDG_CACHE_HOME="$TMP/.cache" # generic hint
   export YARN_CACHE_FOLDER="$TMP/.cache/yarn" # yarn
   # disable creating compiled python code
   export PYTHONDONTWRITEBYTECODE=1

   local result
   local opts
   test "$DEBUG" = "1" && opts+=( "-x" )
   opts+=("-e" "-c")
   pushd "$TMP" > /dev/null || exit
   if test "$QUIET" = "1"; then
      bash "${opts[@]}" "$CMD" 2>&1 | tee "$LOGDIR/${B_NAME}-${B_ARCH}.log" > /dev/null
   else
      bash "${opts[@]}" "$CMD" 2>&1 | tee "$LOGDIR/${B_NAME}-${B_ARCH}.log"
   fi
   result=${PIPESTATUS[0]}
   if test "$result" -ne 0 -a -n "$DEBUGSHELL"; then
      echo "## Build failed. Dropping to shell."
      echo "## See $LOGDIR/${B_NAME}-${B_ARCH}.log for build information."
      echo "## Any changes to the build root will be removed after exit."
      echo "## Type exit to return."
      echo
      PS1="\h:\w buildroot \$ " bash --norc
   fi
   popd > /dev/null || exit
   find "$TMP" -type d -print0 | xargs -0 chmod +w # fix readonly dir removal
   rm -rf "$TMP"
   test "$pkgs" != "" -a "$DEINSTDEP" = "yes" -a "$B_NOPKGRM" -eq 0 && build_require_remove "$pkgs"
   test "$POSTBUILD" != "" -a "$B_NOPKGRM" -eq 0 && $POSTBUILD
   if test "$result" -ne 0; then
      rm -rf "$B_INSTALLDIR"
      return 1
   fi
   return 0
}

arch_get() {
   local arch; arch=$(uname -m)
   case $arch in
   "i686")
     echo i386
     ;;
   "x86_64")
     echo amd64
     ;;
   *)
     echo "$arch"
     ;;
   esac
}

package_buildnr_get() {
   local ID; ID=$1
   test -f "$PKGLIST" || touch "$PKGLIST"
   local BUILDNR; BUILDNR=$(grep "^$ID" "$PKGLIST" | cut -d'	' -f 2 )
   test "$BUILDNR" = "" && BUILDNR=0
   echo $(( BUILDNR + 1 ))
}

package_torepo() {
   local type
   local pkg
   local pkgs; pkgs="$*"
   local splittype
   local RET
   declare -A splittype

   for pkg in $pkgs; do
      type=${pkg/*./}
      splittype[$type]="${splittype[$type]} $pkg"
   done

   cd "$PKGDIR" || exit
   RET=0
   for type in "${!splittype[@]}"; do
      case "$type" in
      "deb")
         $TODEBREPO "${splittype[$type]}"
         test $? -ne 0 && RET=1
      ;;
      *)
         ERR=1 output "Copy to repository not implemented for type $type"
         RET=1
      ;;
      esac
   done
   return $RET
}

package() {
   local pkg; pkg=$1
   local version; version=$2
   local pkgtype
   local ID

   recipe_section_get "$pkg" PKG > /dev/null || exit 1

   if test "$B_INSTANCE" != ""; then
      ID=$version-$B_INSTANCE
   else
      ID=$version
   fi
   if test "$DESTSPLIT" != ""; then
      ID="$pkg/$ID"
   else
      ID="$pkg-$ID"
   fi

   test ! -d "$DESTDIR/$B_ARCH/$ID" && { 
      ERR=1 output "Version $version of $pkg is not available for packaging.";
      return 1; }

   if test "$B_INSTANCE" != ""; then
      ID=${version}-${B_INSTANCE}
   else
      ID=${version}
   fi
   local type; type=$( recipe_item_get "$pkg" PKG type )
   for pkgtype in ${type/,/ }; do
      case $pkgtype in
      "deb")
         if test "$OS" = "Debian GNU/Linux"; then
            package_deb "$pkg" "$version" "$ID"
            return $?
         fi
      ;;
      "rpm")
         if test "$OS" = "CentOS Linux"; then
            package_rpm "$pkg" "$version" "$ID"
            return $?
         fi
      ;;

      *)
         ERR=1 output "Unknown package type ($pkgtype)."
         return 1
      ;;
      esac
   done
}

package_rpm() {
   local pkg; pkg=$1
   local version; version=$2

   local pkgready; pkgready=$( recipe_item_get "$pkg" PKG pkgready )
   local P_PKGDIR; P_PKGDIR="${pkg}-${ID}"

   if test "$pkgready" = ""; then
      local P_PKGNAME; P_PKGNAME="${pkg}_${ID}_${B_ARCH}"
      local P_BUILDNR; P_BUILDNR=$( package_buildnr_get "${P_PKGNAME}" )
      local INFO; INFO=$(recipe_section_get "$pkg" DEB) || return 1
      local TMP; TMP=$( mktemp -p "$TMPDIR" -d )

      echo "P_PKGNAME $P_PKGNAME"
      echo "P_BUILDNR $P_BUILDNR"

      mkdir -p "$TMP/DEBIAN"

      echo "Creating rpm packages is not implemented."
      exit 1
   else
      echo "pkgready not implemented for rpm."
      exit 1
   fi

}

package_deb() {
   local pkg; pkg=$1
   local version; version=$2

   local pkgready; pkgready=$( recipe_item_get "$pkg" PKG pkgready )
   local P_PKGDIR; P_PKGDIR="${pkg}-${ID}"

   local pkgdir
   if test "$DESTSPLIT" != ""; then
      pkgdir="$DESTDIR/$B_ARCH/$pkg/$version"
   else
      pkgdir="$DESTDIR/$B_ARCH/$pkg-$version"
   fi

   if test "$pkgready" = ""; then
      local P_PKGNAME; P_PKGNAME=${pkg}_${ID}_${B_ARCH}
      local P_BUILDNR; P_BUILDNR=$( package_buildnr_get "${P_PKGNAME}" )

      # Find recipe package section
      local INFO
      INFO=$(recipe_section_get -q "$pkg" "DEB $rel")
      if test "$?" -ne 0; then
         INFO=$(recipe_section_get "$pkg" DEB)
         test "$?" -ne 0 && return 1
      fi

      local TMP; TMP=$( mktemp -p "$TMPDIR" -d )
      mkdir -p "$TMP/build/DEBIAN"
      local pkgversion; pkgversion="${version//\-/}-$P_BUILDNR+deb"$(lsb_release -r -s | cut -d'.' -f 1)
      test "$(echo "$INFO" | grep B_DEPENDS)" != "" &&  {
         local CMD; local DEPS;
         CMD=$( recipe_section_get "$pkg" DEB_DEPENDS ); DEPS=$(B_VERSION=$version bash -c "$CMD")
         INFO=$( echo "$INFO" | sed "/^Depends:/ s/B_DEPENDS/$DEPS/" )
      }
      test "$PKGPOSTFIX" != "" && INFO=$( echo "$INFO" | sed "/^Package:/ s/$/-$PKGPOSTFIX/" | sed "s/B_PF/$PKGPOSTFIX/g" )
      test "$PKGPOSTFIX" != "" && INFO="${INFO//B_MAIL/$PKGMAIL}"
      test "$PKGORG" != "" && INFO="${INFO//B_ORG/$PKGORG}"
      test "$PKGMAIL" != "" && INFO="${INFO//B_MAIL/$PKGMAIL}"
      cd "$pkgdir" || exit
      tar pcfB - . | (cd "$TMP/build" || exit ; tar pxfB - )
      cd "$TMP/build" || exit
      if test -d "$RECIPEDIR/$pkg.files/B_DEBIAN"; then
         ( cd "$RECIPEDIR/$pkg.files/B_DEBIAN" || exit ; tar cf - . ) | tar xf -
      fi

      # Mark config files
      find . -path "*/etc/*" -type f | sed "s/^\.//" > DEBIAN/conffiles
      local configfiles; configfiles=$( recipe_item_get "$pkg" PKG configfiles )
      test "$configfiles" != "" && { echo "$configfiles" | tr ' ' '\n' >> DEBIAN/conffiles; }
      echo "$INFO" | sed "s/B_VERSION/$pkgversion/" | sed "s/B_ARCH/$B_ARCH/" > "$TMP"/build/DEBIAN/control
      cd "$TMP" || exit
      fakeroot dpkg --build "$TMP"/build . > "$TMP"/.buildoutput
      result=$?
      local pkgfile; pkgfile=$(cut -d \' -f 4 "$TMP"/.buildoutput)
      pkgfile=${pkgfile/*\//}
      if test $result -ne 0; then
         rm -rf "$TMP"
         ERR=1 output "Error while building package."
         return 1
      fi
      grep "^${P_PKGNAME}_${B_ARCH}" "$PKGLIST" > /dev/null && sed -i "/^${P_PKGNAME}_${B_ARCH}/d" "$PKGLIST"
      echo -e "${P_PKGNAME}_${B_ARCH}\t$P_BUILDNR" >> "$PKGLIST"
      mv "$TMP"/"$pkgfile" "$PKGDIR"
      rm -rf "$TMP"
   else
      if test "$( echo "$pkgdir"/*.deb )" = "$pkgdir/*.deb"; then
         ERR=1 output "Recipe indicates package should be in build dir, but it isn't."
         return 1
      else
         file="$pkgdir/*.deb"
         cp "$file" "$PKGDIR"
         pkgfile=$(basename "$DESTDIR/$B_ARCH/${P_PKGDIR}"/*.deb)
      fi
   fi
   echo "$pkgfile"
}

version_get() {
   local pkg; pkg=$1
   local CMD

   export B_SARCH
   export B_NAME=$1

   B_GITDATE() {
      local url; local br; local head; local dt
      url="$1"
      br="master"
      test "$2" != "" && br="$2"
      # Get head
      head=$(git ls-remote -h "$url" "$br" | cut -d $'\t' -f 1)
      dt=$(( printf "\x1f\x8b\x08\x00\x00\x00\x00\x00" && 
         wget -q -O - "$url"/objects/${head:0:2}/${head:2} ) | 
         gzip -dc 2> /dev/null | cut -d $'\0' -f 1 | 
         grep "^committer" | sed 's/.* \([0-9]\+\) .*/\1/' )
      date -d "@$dt" "+%Y%m%d"
   }

   B_GITVER() {
      local exclude='-e "alpha\|beta\|preview\|rc\|a$\|b$\|b[0-9]*$"'
      local include=""
      local preregex=""
      local postregex=""
      local prefilter="s/^v//"
      local postfilter=""
      local DEBUG=0
      while getopts :aDr:R:i:e:f:F: opt; do
         case $opt in
           r) preregex="$preregex; $OPTARG"
           ;;
           R) postregex="$postregex; $OPTARG"
           ;;
           f) prefilter="$prefilter; s/$OPTARG//"
           ;;
           i) include="$include -e $OPTARG"
           ;;
           e) exclude="$exclude -e $OPTARG"
           ;;
           F) postfilter="$postfilter; s/$OPTARG//"
           ;;
           a) exclude=""
           ;;
           D) DEBUG=1
           ;;
           \?) echo "Unknown option: -$OPTARG"
           ;;
           :) echo "Option -$OPTARG requires argument"
           ;;
         esac
      done
      shift $((OPTIND -1))
      test "$preregex"  != "" && preregex="sed \"$preregex\"" || preregex="cat"
      prefilter="sed \"$prefilter\""
      test "$include" != "" && include="grep -i $include" || include="cat"
      test "$exclude" != "" && exclude="grep -iv $exclude" || exclude="cat"
      test "$postfilter" != "" && postfilter="sed \"$postfilter\""|| postfilter="cat"

      test "$postregex" != "" && postregex="sed \"$postregex\"" || postregex="cat"
      local CMD="git ls-remote --tags $1 | grep -v '{}' | 
                 sed 's#.*refs/tags/##' |
                 $preregex | 
                 $prefilter | 
                 $include | 
                 $exclude | 
                 $postfilter | 
                 $postregex | 
                 sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n | tail -1"
      test "$DEBUG" = 1 && echo "$CMD" > /tmp/b_gitver
      bash -c "$CMD"
   }
   B_GITLABVER() {
      local USR
      local REPO
      local BRANCH="$2"
      USR="$( echo "$1" | cut -d'/' -f 4)"
      REPO="$( echo "$1" | cut -d'/' -f 5)"
      wget -q -O - https://gitlab.com/api/v4/projects/"$USR"%2F"$REPO"/repository/commits?ref_name="${BRANCH:=master}" | jq -r '.[0].committed_date[0:10] | gsub("-";"")'
   }
   B_GITHUBVER() {
      local URL="$1"
      local BRANCH="$2"
      wget -q -O - https://api.github.com/repos/"${URL/*github.com\//}"/commits/"${BRANCH:=master}" | jq -cr '.commit.committer.date[0:10] | gsub("-";"")'
   }
   B_SFVER() {
      local URL="$1"
      wget -q -O - "$URL/rss?path=/" | xml2 | grep '/rss/channel/item/link' | sed 's/.*\/files\/\([^\/]\+\)\/.*/\1/; s/.\+-\(.\+\)/\1/' | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n | tail -1
   }

   B_SVNDATE() {
      date -d "$(svn info --non-interactive --trust-server-cert "$1" | grep 'Last Changed Date:' | cut -d':' -f2-)" "+%Y%m%d"
   }

   B_SVNREV() {
      svn info --non-interactive --trust-server-cert "$1" | grep Revision | cut -d' ' -f2
   }

   B_HGREV() {
      hg id "$1"
   }

   export -f B_GITVER B_GITDATE B_GITHUBVER B_SVNDATE B_SVNREV B_HGREV B_GITLABVER B_SFVER
   CMD=$( recipe_section_get "$pkg" VERSION )
   test $? -ne 0 && { output "$CMD" ; return 1; }
   local opts
   test "$DEBUG" = "1" && opts+=("-x")
   opts+=("-e" "-c")
   local ver; ver=$( bash "${opts[@]}" "$CMD" 2>/dev/null )
   test $? -ne 0 && { >&2 output "Error while running version command for $pkg." ; return 1 ; }
   test "$ver" = "" && { >&2 output "Version command for $pkg returned no output." ; return 1 ; }
   echo "$ver"
   return 0
}

# Check if recipe has build section for this system
recipe_select_build() {
   local recipe
   recipe=$1

   if ! recipe_section_get -q "$recipe" "BUILD $distr $rel" > /dev/null; then
      if ! recipe_section_get -q "$recipe" "BUILD $distr" > /dev/null ; then
         if ! recipe_section_get -q "$recipe" "BUILD" > /dev/null; then
            return 1
         fi
      fi
   fi
   return 0
}

# Check if recipe has is for this architecture
recipe_select_arch() {
   local recipe; recipe=$1
   local arch; arch=$( recipe_item_get "$recipe" INFO arch )
   test "$arch" = "" && arch="$B_SARCH"
   for B_ARCH in ${arch/,/ }; do
      if test "$B_ARCH" = "all" -o "$B_ARCH" = "$B_SARCH"
      then
         return 0
      fi
   done
   return 1
}

# Check which build recipe section should be used for building (if any)
recipe_check_builddistro() {
# * determine OS name
# * determine version name
# * check if build exists, if yes, return build
# * check if build os exists, if yes return build os
# * check if build os version exists, if yes return build os version
# * return no
   local recipe; recipe=$1
   local arch; arch=$( recipe_item_get "$recipe" INFO arch )
   test "$arch" = "" && arch="$B_SARCH"
   for B_ARCH in ${arch/,/ }; do
      if test "$B_ARCH" = "all" -o "$B_ARCH" = "$B_SARCH"
      then
         return 0
      fi
   done
   return 1
}

parse_options() {
   B_FORCE=0 ; DEBUG= ; DEBUGSHELL= ; FORCEVERSION=
   DO_CHECK=0; DO_BUILD=0; DO_PACKAGE=0; DO_REPO=0; B_NOPKGRM=0
   local all; all=0

   while getopts :csbprai:Rxqfhv: opt; do
      case $opt in
      c)
         DO_CHECK=1
      ;;
      b)
         DO_CHECK=2
         DO_BUILD=1
      ;;
      p)
         DO_CHECK=2
         DO_PACKAGE=1
      ;;
      r)
         DO_CHECK=2
         DO_PACKAGE=2
         DO_REPO=1
      ;;
      a)
         all=1
      ;;
      i)
         B_INSTANCE="$OPTARG"
      ;;
      R)
         B_NOPKGRM=1
      ;;
      x)
         DEBUG=1
      ;;
      s)
         DEBUGSHELL=1
      ;;
      q)
         QUIET=$(( QUIET +1 ))
      ;;
      f)
         B_FORCE=1
      ;;
      h)
         usage
      ;;
      v)
         FORCEVERSION="$OPTARG"
      ;;
      \?)
         echo "Unknown option: -$OPTARG"
         usage
      ;;
      :)
         echo "Option -$OPTARG requires argument"
         usage
      ;;
      esac
   done
   shift $((OPTIND -1))

   if test "$DO_CHECK" = "0" -a "$DO_BUILD" = "0" -a "$DO_PACKAGE" = "0" -a "$DO_REPO" = "0"; then
      output "No action specified."
      exit 1
   fi

   for recipe in "$@"; do
      if recipe_select_arch "$recipe"; then
         work_recipes+=("$recipe")
         work_arch[$recipe]=$B_ARCH
      else
         output "$recipe not for this architecture."
      fi
   done

   if test $all -eq 1; then
      local recipe
      for recipe in "$RECIPEDIR"/*.recipe; do
         recipe=$( basename -s .recipe "$recipe" )
         exclude=$( recipe_item_get "$recipe" INFO excludefromall )
         if test "$exclude" != "1"; then
            if recipe_select_arch "$recipe"; then
               if recipe_select_build "$recipe"; then
                  work_recipes+=( "$recipe" )
                  work_arch[$recipe]="$B_ARCH"
               else
                  output "$recipe has no build section for this system."
               fi
            else
               output "$recipe not for this architecture or no build section."
            fi
         else
            output "$recipe excluded from building."
         fi
      done
   fi

   if test ${#work_recipes[@]} -eq 0; then
      output "No recipe(s) specified."
      exit 1
   fi
}

sanity_check() {
   local missing; missing=""
   local name

   for name in $( require_software); do
      if ! command -v "$name" > /dev/null 2>&1
      then
         missing="$missing $name"
      fi
   done
   test "$missing" != "" && { output "Missing required software to run script:$missing" ; exit 1;}
   test "$PKGDIR" = ""  && { ERR=1 output "PKGDIR not defined"; exit 1;}
   test -d "$PKGDIR" || { ERR=1 output "PKGDIR $PKGDIR does not exist, creating."; mkdir -p "$PKGDIR"; }
   test -d "$LOGDIR" || { ERR=1 output "LOGDIR $LOGDIR does not exist, creating."; mkdir -p "$LOGDIR"; }
   test -d "$TMPDIR" || { ERR=1 output "TMPDIR $TMPDIR does not exist, creating."; mkdir -p "$TMPDIR"; }
}

output() {
   local force; force=0
   test "$1" = "-f" && { force=1; shift; }
   test $QUIET -eq 2 && return
   test $force -eq 0 -a $QUIET -eq 1 && return
   test "$ERR" != "" && (>&2 echo "$1") || echo "$1"
}

check_version_built() {
   local pkg; pkg=$1
   local RET; RET=0
   local version
   local pkgdir

   if test "$FORCEVERSION" != ""; then
      version=$FORCEVERSION
   else
      version=$( version_get "$pkg" ) || return 2
   fi
   if test "$DESTSPLIT" != ""; then
      pkgdir="$DESTDIR/$B_ARCH/$pkg/$version"
   else
      pkgdir="$DESTDIR/$B_ARCH/$pkg-$version"
   fi
   test -d "$pkgdir" && { echo "$version" ; RET=1 ;} || echo "$version"
   return $RET
}

lock_get() {
   test -z "$B_METABUILD" && return 0
   if test -f "$LOCK" && pgrep -F "$LOCK" > /dev/null; then
      return 1
   else
      echo "$$" > "$LOCK"
      return 0
   fi
}

lock_free() {
   test -z "$B_METABUILD" && return 0
   rm -f "$LOCK"
}

main() {
   local i
   local retval; retval=0
   declare -A work_arch
   LOCK=/tmp/build.lck
   QUIET=0

   ! test -f /etc/os-release && { echo "Unable to determine os, no /etc/os-release."; exit 1; }
   OS=$(grep "^NAME" /etc/os-release)
   eval "${OS/*=/OS=}"
   DESTDIR="$HOME/build" CACHEDIR="$HOME/cache" TMPDIR="$HOME/temp"
   RECIPEDIR="$HOME/recipes" PKGLIST=$RECIPEDIR/pkglist PKGDIR="$HOME/packages"; LOGDIR="$HOME/log"
   INSTDEP=yes DEINSTDEP=yes
   if test -f "$HOME/.buildrc";then
      # shellcheck source=/home/builduser/.buildrc
      source "$HOME/.buildrc"
   else
      echo "No configuration file found."
      exit 1
   fi

   sanity_check

   distr=$(lsb_release -i -s | tr '[:lower:]' '[:upper:]')
   rel=$(lsb_release -c -s | tr '[:lower:]' '[:upper:]')

   test "$PROXY" != "" && { export http_proxy=$PROXY; export https_proxy=$PROXY; }

   B_SARCH=$( arch_get )
   parse_options "$@"

   # Check version
   if test $DO_CHECK -ne 0; then
      # Get current version and check if already built
      for i in "${!work_recipes[@]}"; do
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         work_version[$i]=$( check_version_built "${work_recipes[$i]}" )
         work_built[$i]=$?
         if test $DO_CHECK -eq 1 -o $DO_BUILD -eq 1 -a $B_FORCE -eq 0; then
            if test ${work_built[$i]} -eq 1; then
               output "${work_recipes[$i]} ${work_version[$i]} (already built)"
            fi
         fi
         if test $DO_CHECK -eq 1 -o $DO_PACKAGE -ne 0; then
            if test ${work_built[$1]} -eq 0; then
               output "${work_recipes[$i]} ${work_version[$i]} (not built)"
            fi
         fi
      done
   fi

   # Build
   if test $DO_BUILD -ne 0; then
      # If not built or forced, then build
      lock_get || { echo "Unable to get lock, other instance running?"; exit 1; }
      for i in "${!work_recipes[@]}"; do
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         if test ${work_built[$i]} -eq 0 -o $B_FORCE -eq 1; then
            build "${work_recipes[$i]}" "${work_version[$i]}"
            if test $? -eq 1;then
               output -f "${work_recipes[$i]} ${work_version[$i]} (build failed)"
               work_build[$i]=0
               retval=1;
            else
               work_build[$i]=1
               output -f "${work_recipes[$i]} ${work_version[$i]} (build succeeded)"
            fi
         fi
      done
      lock_free
   fi

   # Create package
   if test $DO_PACKAGE -ne 0; then
      # if no build action and version built, package.
      # if build action successful, build.
      local built
      for i in "${!work_recipes[@]}"; do
         work_packaged[$i]=1
         B_ARCH=${work_arch[${work_recipes[$i]}]}
         built=0
         test "$DO_BUILD" -eq 0 -a "${work_built[$i]}" = 1 && built=1
         test "${work_build[$i]}" = "1" && built=1
         if test "$built" -eq 1; then
            work_package[$i]=$(package "${work_recipes[$i]}" "${work_version[$i]}")
            work_packaged[$i]=$?
            if test "${work_packaged[$i]}" -eq 0; then
               output "${work_recipes[$i]} ${work_version[$i]} (package created)"
            else
               output -f "${work_recipes[$i]} ${work_version[$i]} (package create failed)"
               retval=1
            fi
         fi
      done
   fi

   # Push to repo
   if test $DO_REPO -ne 0; then
      lock_get || { echo "Unable to get lock, other instance running?"; exit 1; }
      local pkgs
      unset pkgs
      for i in "${!work_recipes[@]}"; do
         test "${work_packaged[$i]}" = "0" && pkgs+=( "${work_package[$i]}" )
      done
      B_ARCH=${work_arch[${work_recipes[$i]}]}
      if test "${#pkgs[*]}" != "0"; then
         package_torepo "${pkgs[@]}"
         if test $? -eq 0; then
            output "packages pushed to repo"
         else
            output -f "packages not pushed to repo"
            retval=1
         fi
      fi
      lock_free
   fi

   return $retval
}

main "$@"
